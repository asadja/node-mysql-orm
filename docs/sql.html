<!DOCTYPE html>
<!-- Generated by litjs - https://github.com/apres/lit.js
     Part of the Apres suite - http://apres.github.com/ -->
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <title>mysql-orm: sql.js</title>
  <link href='css/lit-callouts.css' rel='stylesheet' type='text/css'>
  <link href='css/apres.css' rel='stylesheet' type='text/css'>
</head>
<body>
  <div class="lit">
<section>
<div class="lit-comment">
<h1>mysql-orm: sql.js</h1>
</div>
<code class="lit-code">
<span class="string">'use strict'</span>;

<span class="comment">/*
 * MySQL object-relational mapping
 * ===============================
 *
 * (C) 2014 Mark K Cowan &lt;mark@battlesnake.co.uk>
 *
 * https://github.com/battlesnake/node-mysql-orm
 *
 * Released under GNU General Public License, Version 2
 *
 */</span>

<span class="keyword">var</span> mysql = require(<span class="string">'mysql'</span>);
<span class="keyword">var</span> async = require(<span class="string">'async'</span>);
<span class="keyword">var</span> _ = require(<span class="string">'underscore'</span>);

<span class="keyword">var</span> utils = require(<span class="string">'./utils'</span>);
<span class="keyword">var</span> names = utils.names;
<span class="keyword">var</span> shift = utils.shift;
</code>
</section>
<section>
<div class="lit-comment">
<h1>sql</h1>

<p>SQL clause generators</p>

<h2>SELECT &lt;fields&gt;</h2>

<p><code>$fields</code> can contain a mix of field references and field names.<br />Defaults to '*' if no fields are specified.</p>
</div>
<code class="lit-code">
module.exports.select = <span class="function"><span class="keyword">function</span> <span class="params">(self, fields, callback)</span> {</span>
  <span class="keyword">if</span> (fields) {
    fields = fields.map(
      <span class="function"><span class="keyword">function</span> <span class="params">(field)</span> {</span>
        <span class="keyword">if</span> (field.$type === <span class="string">'field'</span>) {
          <span class="keyword">return</span> field.$name;
        }
        <span class="keyword">else</span> {
          <span class="keyword">return</span> field;
        }
      }
    );
    <span class="keyword">return</span> callback(<span class="literal">null</span>, mysql.format(<span class="string">'SELECT ??'</span>, [fields]));
  }
  <span class="keyword">else</span> {
    <span class="keyword">return</span> callback(<span class="literal">null</span>, <span class="string">'SELECT *'</span>);
  }
};
</code>
</section>
<section>
<div class="lit-comment">
<h2>DELETE</h2>

<p>No point making this async-style, it can never take parameters.  QUICK and<br />IGNORE are irrelevant as performance is not an objective of this package.</p>

<p>Then again, I like having my clause lists in async.parallel, and as stated,<br />performance is not important in this library, so &quot;async style&quot; it is.</p>
</div>
<code class="lit-code">
module.exports.<span class="keyword">delete</span> = <span class="function"><span class="keyword">function</span> <span class="params">(callback)</span> {</span>
  callback(<span class="literal">null</span>, <span class="string">'DELETE'</span>);
}
</code>
</section>
<section>
<div class="lit-comment">
<h2>table name</h2>

<p>Table can be a string or a table reference.</p>
</div>
<code class="lit-code">
<span class="function"><span class="keyword">function</span> <span class="title">tableName</span><span class="params">(table, callback)</span> {</span>
  <span class="keyword">if</span> (_(table).isString()) {
    <span class="keyword">return</span> callback(<span class="literal">null</span>, mysql.escapeId(table));
  }
  <span class="keyword">else</span> <span class="keyword">if</span> (table.$type === <span class="string">'table'</span>) {
    <span class="keyword">return</span> callback(<span class="literal">null</span>, mysql.escapeId(table.$name));
  }
  <span class="keyword">else</span> {
    <span class="keyword">return</span> callback(<span class="keyword">new</span> Error(<span class="string">'Unknown table specification: "'</span> + table +
      <span class="string">'"'</span>));
  }
}
</code>
</section>
<section>
<div class="lit-comment">
<h2>INSERT INTO &lt;table name&gt;</h2>

<p>Table can be a table reference or a table name.</p>
</div>
<code class="lit-code">
module.exports.insertInto = <span class="function"><span class="keyword">function</span> <span class="params">(self, table, callback)</span> {</span>
  tableName(table, <span class="function"><span class="keyword">function</span> <span class="params">(err, res)</span> {</span>
    <span class="keyword">if</span> (err) {
      <span class="keyword">return</span> callback(err);
    }
    callback(<span class="literal">null</span>, <span class="string">'INSERT INTO '</span> + res);
  });
};
</code>
</section>
<section>
<div class="lit-comment">
<h2>UPDATE &lt;table name&gt;</h2>

<p>Table can be a table reference or a table name.</p>
</div>
<code class="lit-code">
module.exports.update = <span class="function"><span class="keyword">function</span> <span class="params">(self, table, callback)</span> {</span>
  tableName(table, <span class="function"><span class="keyword">function</span> <span class="params">(err, res)</span> {</span>
    <span class="keyword">if</span> (err) {
      <span class="keyword">return</span> callback(err);
    }
    callback(<span class="literal">null</span>, <span class="string">'UPDATE '</span> + res);
  });
};
</code>
</section>
<section>
<div class="lit-comment">
<h2>FROM &lt;table name&gt;</h2>

<p>Table can be a table reference or a table name.</p>
</div>
<code class="lit-code">
module.exports.from = <span class="function"><span class="keyword">function</span> <span class="params">(self, table, callback)</span> {</span>
  tableName(table, <span class="function"><span class="keyword">function</span> <span class="params">(err, res)</span> {</span>
    <span class="keyword">if</span> (err) {
      <span class="keyword">return</span> callback(err);
    }
    callback(<span class="literal">null</span>, <span class="string">'FROM '</span> + res);
  });
};
</code>
</section>
<section>
<div class="lit-comment">
<h2>WHERE &lt;criteria&gt;</h2>

<p>Properties of criteria are used to generate search constraints.  Foreign row<br />IDs are looked up where necessary to generate these constraints.</p>
</div>
<code class="lit-code">
module.exports.where = <span class="function"><span class="keyword">function</span> <span class="params">(self, query, table, criteria, callback)</span> {</span>
  <span class="keyword">var</span> cols = _(criteria).keys();
  criteria = _(criteria).clone();
  <span class="keyword">if</span> (table.$primary.length === <span class="number">1</span> &amp;&amp; _(criteria).has(table.$primary)) {
    <span class="keyword">var</span> primary = table.$primary[<span class="number">0</span>];
    criteria = _.object([primary], [criteria[primary]]);
    cols = [primary]
  }
  <span class="keyword">if</span> (cols.length) {
    <span class="keyword">if</span> (_(table).isString()) {
      table = self.schema[table];
    }
    <span class="keyword">var</span> refs = self.listForeignKeys(table);
    <span class="keyword">if</span> (refs.length) {
      self.lookupForeignIds(query, table, criteria, { cols: cols }, <span class="function"><span class="keyword">function</span> <span class="params">(err, res)</span> {</span>
        <span class="keyword">if</span> (err) {
          <span class="keyword">return</span> callback(err);
        }
        generateClause(res);
      });
    }
    <span class="keyword">else</span> {
      generateClause(criteria);
    }
  }
  <span class="keyword">else</span> {
    <span class="keyword">return</span> callback(<span class="literal">null</span>);
  }
  <span class="function"><span class="keyword">function</span> <span class="title">generateClause</span><span class="params">(row)</span> {</span>
    cols.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(fieldName)</span> {</span>
      <span class="keyword">var</span> field = table[fieldName];
      <span class="keyword">if</span> (field.serialize) {
        row[fieldName] = field.serialize(row[fieldName]);
      }
    });
    <span class="keyword">return</span> callback(<span class="literal">null</span>,
      <span class="string">'WHERE\n\t'</span> + cols
        .map(<span class="function"><span class="keyword">function</span> <span class="params">(col)</span> {</span>
          <span class="keyword">return</span> mysql.format(<span class="string">'??=?'</span>, [col, row[col]]);
        })
        .join(<span class="string">' AND\n\t'</span>));
  }
};
</code>
</section>
<section>
<div class="lit-comment">
<h2>ORDER BY &lt;field [direction]&gt;</h2>

<p>criteria.$sort property, or (as fallback) table.$sort are used to generate<br />sorting instructions.  $sort can be a field name/reference or an array of<br />such.  Begin field names with +/- to specify ascending or descending sort<br />order.</p>
</div>
<code class="lit-code">
module.exports.orderby = <span class="function"><span class="keyword">function</span> <span class="params">(self, table, sort, callback)</span> {</span>
  <span class="keyword">var</span> sort = sort || table.$sort || [];
  <span class="keyword">if</span> (sort.length) {
    <span class="keyword">if</span> (_(sort).isString()) {
      sort = [sort];
    }
    <span class="keyword">return</span> callback(<span class="literal">null</span>, <span class="string">'ORDER BY\n\t'</span> + sort.map(<span class="function"><span class="keyword">function</span> <span class="params">(field)</span> {</span>
      <span class="keyword">if</span> (field.$type === <span class="string">'field'</span>) {
        field = field.$name;
      }
      <span class="keyword">if</span> (!_(field).isString()) {
        <span class="keyword">return</span> callback(<span class="keyword">new</span> Error(<span class="string">'$sort must either be a field '</span> +
          <span class="string">'name a field reference, or an array of field '</span> +
          <span class="string">'names/references'</span>));
      }
      <span class="keyword">if</span> (field.charAt(<span class="number">0</span>) === <span class="string">'-'</span>) {
        <span class="keyword">return</span> mysql.escapeId(field.substr(<span class="number">1</span>)) + <span class="string">' DESC'</span>;
      }
      <span class="keyword">else</span> <span class="keyword">if</span> (field.charAt(<span class="number">0</span>) === <span class="string">'+'</span>) {
        <span class="keyword">return</span> mysql.escapeId(field.substr(<span class="number">1</span>)) + <span class="string">' ASC'</span>;
      }
      <span class="keyword">else</span> {
        <span class="keyword">return</span> mysql.escapeId(field);
      }
    }).join(<span class="string">',\n\t'</span>));
  }
  <span class="keyword">else</span> {
    <span class="keyword">return</span> callback(<span class="literal">null</span>);
  }
};
</code>
</section>
<section>
<div class="lit-comment">
<h2>LIMIT &lt;count&gt; [OFFSET &lt;start&gt;]</h2>

<p>Uses a combination of $first, $last and $count to generate a LIMIT clause.</p>
</div>
<code class="lit-code">
module.exports.limit = <span class="function"><span class="keyword">function</span> <span class="params">(self, options, callback)</span> {</span>
  <span class="keyword">var</span> lparams =
    _(options).has(<span class="string">'first'</span>)?<span class="number">1</span>:<span class="number">0</span> +
    _(options).has(<span class="string">'count'</span>)?<span class="number">2</span>:<span class="number">0</span> +
    _(options).has(<span class="string">'last'</span>) ?<span class="number">4</span>:<span class="number">0</span>;
  <span class="keyword">var</span> first = options.first, last = options.last, count = options.count;
  <span class="keyword">switch</span> (lparams) {
    <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> callback(<span class="literal">null</span>);
    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> callback(<span class="keyword">new</span> Error(<span class="string">'first value for LIMIT specified, but no last or count value'</span>));
    <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> callback(<span class="literal">null</span>, mysql.format(<span class="string">'LIMIT ?'</span>, [count])); <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> callback(<span class="literal">null</span>, mysql.format(<span class="string">'LIMIT ?\nOFFSET ?'</span>, [count, first])); <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="number">4</span>:  <span class="keyword">return</span> callback(<span class="keyword">new</span> Error(<span class="string">'last value for LIMIT specified, but no first or count value'</span>));
    <span class="keyword">case</span> <span class="number">5</span>: <span class="keyword">return</span> callback(<span class="literal">null</span>, mysql.format(<span class="string">'LIMIT ?\nOFFSET ?'</span>, [last - first, first])); <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="number">6</span>: <span class="keyword">return</span> callback(<span class="literal">null</span>, mysql.format(<span class="string">'LIMIT ?\nOFFSET ?'</span>, [count, last - count])); <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="number">7</span>: <span class="keyword">return</span> callback(<span class="keyword">new</span> Error(<span class="string">'first, last, count were all specified for LIMIT'</span>));
  }
};
</code>
</section>
<section>
<div class="lit-comment">
<h2>ON DUPLICATE KEY UPDATE &lt;name = VALUES(name), ...&gt;</h2>

<p>Generates a list of copy assignments</p>
</div>
<code class="lit-code">
module.exports.onDuplicateKeyUpdate = <span class="function"><span class="keyword">function</span> <span class="params">(self, keys, callback)</span> {</span>
  callback(<span class="literal">null</span>,
    <span class="string">'ON DUPLICATE KEY UPDATE\n\t'</span> + keys.map(
      <span class="function"><span class="keyword">function</span> <span class="params">(key)</span> {</span>
        <span class="keyword">return</span> mysql.format(<span class="string">'?? = VALUES(??)'</span>, [key, key]);
      }
    ).join(<span class="string">',\n\t'</span>));
};
</code>
</section>
<section>
<div class="lit-comment">
<h2>SET &lt;name = value, ...&gt;</h2>

<p>Generates a list of assignments</p>
</div>
<code class="lit-code">
module.exports.set = <span class="function"><span class="keyword">function</span> <span class="params">(self, keys, row, callback)</span> {</span>
  <span class="keyword">if</span> (!keys) {
    keys = names(row);
  }
  callback(<span class="literal">null</span>,
    <span class="string">'SET\n\t'</span> + keys.map(
      <span class="function"><span class="keyword">function</span> <span class="params">(key)</span> {</span>
        <span class="keyword">return</span> mysql.format(<span class="string">'?? = ?'</span>, [key, row[key]]);
      }
    ).join(<span class="string">',\n\t'</span>));
};
</code>
</section>
</div>

</body>
</html>
