<!DOCTYPE html>
<!-- Generated by litjs - https://github.com/apres/lit.js
     Part of the Apres suite - http://apres.github.com/ -->
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <title>mysql-orm: save.js</title>
  <link href='css/lit-callouts.css' rel='stylesheet' type='text/css'>
  <link href='css/apres.css' rel='stylesheet' type='text/css'>
</head>
<body>
  <div class="lit">
<section>
<div class="lit-comment">
<h1>mysql-orm: save.js</h1>
</div>
<code class="lit-code">
<span class="string">'use strict'</span>;

<span class="comment">/*
 * MySQL object-relational mapping
 * ===============================
 *
 * (C) 2014 Mark K Cowan &lt;mark@battlesnake.co.uk>
 *
 * https://github.com/battlesnake/node-mysql-orm
 *
 * Released under GNU General Public License, Version 2
 *
 */</span>

<span class="keyword">var</span> mysql = require(<span class="string">'mysql'</span>);
<span class="keyword">var</span> async = require(<span class="string">'async'</span>);
<span class="keyword">var</span> _ = require(<span class="string">'underscore'</span>);

<span class="keyword">var</span> utils = require(<span class="string">'./utils'</span>);
<span class="keyword">var</span> sql = require(<span class="string">'./sql'</span>);

<span class="keyword">var</span> names = utils.names;
<span class="keyword">var</span> parse_args = utils.parse_args;

<span class="keyword">var</span> ORM = { prototype: {} };
module.exports = ORM.prototype;
</code>
</section>
<section>
<div class="lit-comment">
<h1>save</h1>

<p>Saves data to the database</p>

<p>NOTE: REPLACE will not be supported as it (quite rightly) wrecks foreign<br />keys.  if you want to replace, do a delete followed by a save.</p>

<h2>save([query] table row [options] callback)</h2>

<p>Save a single row to table, updating when the primary key value matches an<br />existing row and inserting otherwise.  Foreign key values are looked up<br />automatically.</p>

<ul>
<li>table - A table definition from the schema.</li>
<li>row - An object representing the values to save.  Foreign key values
are resolved, see the foreign-keys module for more information.</li>
<li>options</li>
<li>save - Specifies whether save can create/overwrite rows.</li>
<li>'new' - Only create a new row, fail on existing id</li>
<li>'existing' - Only update existing row, fail if id is not found</li>
<li>'always' (default) - create or update</li>
</ul>

<h3>Example which creates a new record</h3>

<p>// The following adds a new record as no primary key id was specified<br />save(<br />schema.users,<br />{<br />name: 'mark',<br />role: { value: 'admin' },<br />country: { value: 'Lithuania' }<br />},<br />function (err) { ... });</p>

<h3>Example which saves to existing record, or creates new one if not found</h3>

<p>// The following will update an existing record if the id already<br />// exists in the table, otherwise it will insert a new record<br />save(<br />schema.users,<br />{<br />id: 1,<br />name: 'mark',<br />role: { value: 'admin' },<br />country: { value: 'Lithuania' }<br />},<br />function (err) { ... });</p>
</div>
<code class="lit-code">
ORM.prototype.save = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> args = parse_args(<span class="keyword">this</span>, arguments);
  <span class="keyword">var</span> query = args.query;
  <span class="keyword">var</span> table = args.table;
  <span class="keyword">var</span> row = args.data;
  <span class="keyword">var</span> options = args.options;
  <span class="keyword">var</span> callback = args.callback;
  <span class="keyword">var</span> self = <span class="keyword">this</span>;
  async.waterfall([
      <span class="function"><span class="keyword">function</span> <span class="params">(callback)</span> {</span>
        <span class="comment">/* Serialize */</span>
        _(table).keys().forEach(<span class="function"><span class="keyword">function</span> <span class="params">(key)</span> {</span>
          <span class="keyword">if</span> (table[key].serialize) {
            row[key] = table[key].serialize(row[key]);
          }
        });
        <span class="comment">/* Lookup reference IDs */</span>
        self.lookupForeignIds(query, table, row, <span class="function"><span class="keyword">function</span> <span class="params">(err, res)</span> {</span>
            row = res;
            callback(err);
          });
      },
      <span class="function"><span class="keyword">function</span> <span class="params">(callback)</span> {</span>
        <span class="keyword">var</span> saveMode = options.save || <span class="string">'always'</span>;
        <span class="keyword">if</span> (saveMode === <span class="string">'always'</span>) {
          async.parallel([
              async.apply(sql.insertInto, self, table),
              async.apply(sql.set, self, names(row), row),
              async.apply(sql.onDuplicateKeyUpdate, self,
                _(names(row)).without(table.$primary))
            ],
            <span class="function"><span class="keyword">function</span> <span class="params">(err, data)</span> {</span>
              <span class="keyword">if</span> (err) {
                <span class="keyword">return</span> callback(err);
              }
              execQuery(data.join(<span class="string">'\n'</span>));
            });
        }
        <span class="keyword">else</span> <span class="keyword">if</span> (saveMode === <span class="string">'new'</span>) {
          async.parallel([
              async.apply(sql.insertInto, self, table),
              async.apply(sql.set, self, names(row), row),
            ],
            <span class="function"><span class="keyword">function</span> <span class="params">(err, data)</span> {</span>
              <span class="keyword">if</span> (err) {
                <span class="keyword">return</span> callback(err);
              }
              execQuery(data.join(<span class="string">'\n'</span>));
            });
        }
        <span class="keyword">else</span> <span class="keyword">if</span> (saveMode === <span class="string">'existing'</span>) {
          <span class="keyword">if</span> (table.$primary.length === <span class="number">0</span>) {
            <span class="keyword">return</span> callback(<span class="keyword">new</span> Error(<span class="string">'Cannot save to existing '</span> +
              <span class="string">'row: table has no primary key'</span>));
          }
          <span class="keyword">var</span> criteria = _(row).pick(table.$primary);
          async.parallel([
              async.apply(sql.update, self, table),
              async.apply(sql.set, self, _(names(row)).without(table.$primary), row),
              async.apply(sql.where, self, query, table, criteria)
            ],
            <span class="function"><span class="keyword">function</span> <span class="params">(err, data)</span> {</span>
              <span class="keyword">if</span> (err) {
                <span class="keyword">return</span> callback(err);
              }
              execQuery(data.join(<span class="string">'\n'</span>));
            });
        }
        <span class="keyword">else</span> {
          <span class="keyword">return</span> callback(<span class="keyword">new</span> Error(<span class="string">'Unknown save mode: '</span> + saveMode));
        }
        <span class="comment">/* Executes the query */</span>
        <span class="function"><span class="keyword">function</span> <span class="title">execQuery</span><span class="params">(sql)</span> {</span>
          query(sql, <span class="literal">null</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err, res)</span> {</span>
            <span class="keyword">if</span> (err) {
              <span class="keyword">return</span> callback(err);
            }
            <span class="keyword">if</span> (res.affectedRows === <span class="number">0</span>) {
              <span class="keyword">return</span> callback(<span class="keyword">new</span> Error(<span class="string">'Failed to save row '</span> +
                <span class="string">'with mode '</span> + saveMode));
            }
            <span class="keyword">if</span> (_(res).has(<span class="string">'insertId'</span>)) {
              row[table.$auto_increment] = res.insertId;
            }
            callback(err);
          });
        }
      }
    ],
    <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span> callback(err); });
};
</code>
</section>
<section>
<div class="lit-comment">
<h2>saveMany([query] table rows [options] callback)</h2>

<p>Resolves foreign key values and saves sets of rows to the database</p>

<p>Saves a load of rows to the table, updating when the primary key value<br />matches an existing row and inserting otherwise.  Foreign key values are<br />looked up automatically.  Internally, this calls save.</p>

<ul>
<li>table - A table definition from the schema.</li>
<li>rows - An array of rows to save.  Foreign key values are resolved, see the
foreign-keys module for more information.</li>
<li>options - see documentation for save()</li>
</ul>

<h3>Example</h3>

<p>saveMany(<br />schema.users,<br />[<br />{<br />id: 1,<br />name: 'mark',<br />country: { value: 'United Kingdom' },<br />role: { value: 'admin' }<br />},<br />{<br />id: 2,<br />name: 'marili',<br />country: { value: 'Estonia' },<br />role: { value: 'ploom' },<br />},<br />],<br />{ save: 'existing' },<br />function (err) { .. });</p>
</div>
<code class="lit-code">
ORM.prototype.saveMany = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> args = parse_args(<span class="keyword">this</span>, arguments);
  <span class="keyword">var</span> query = args.query;
  <span class="keyword">var</span> table = args.table;
  <span class="keyword">var</span> rows = args.data;
  <span class="keyword">var</span> options = args.options;
  <span class="keyword">var</span> callback = args.callback;
  <span class="keyword">var</span> self = <span class="keyword">this</span>;
  async.each(rows,
    <span class="function"><span class="keyword">function</span> <span class="params">(row, callback)</span> {</span>
      self.save(query, table, row, options, callback);
    },
    <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span> callback(err); });
};
</code>
</section>
<section>
<div class="lit-comment">
<h2>saveMultipleTables(data, callback)</h2>

<p>Save sets of rows to several tables, looking up foreign keys where needed.</p>

<ul>
<li>data - An object of the form { tableName: rows, tableName: rows, ... }.</li>
</ul>

<p>Note: tables are procesed in the order that their fields appear in the data<br />object.  This relies on V8 honouring field order, which ECMAScript specs do<br />not require it to do.  This also makes circular dependencies on foreign keys<br />impossible to process with a single call to this function.  Internally, this<br />calls saveMany.</p>

<h3>Example</h3>

<p>saveMultipletables(<br />{<br />countries: [<br />{ id: 44, name: 'United Kingdom' },<br />{ id: 372, name: 'Estonia' }],<br />roles: [<br />{ name: 'admin', rights: '*' },<br />{ name: 'ploom', rights: 'being_awesome,being_a_ploom' }],<br />users: [<br />{ <br />name: 'mark',<br />country: { name: 'United Kingdom' },<br />role: { name: 'admin' }<br />},<br />{<br />name: 'marili',<br />country: { name: 'Estonia' },<br />role: { name: 'ploom' }<br />}]<br />},<br />function (err) { ... });</p>
</div>
<code class="lit-code">
ORM.prototype.saveMultipleTables = <span class="function"><span class="keyword">function</span> <span class="params">(data, callback)</span> {</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>;
  <span class="keyword">this</span>.beginTransaction(<span class="function"><span class="keyword">function</span> <span class="params">(err, transaction)</span> {</span>
    <span class="keyword">if</span> (err) {
      <span class="keyword">return</span> callback(err);
    }
    async.series([
        <span class="function"><span class="keyword">function</span> <span class="params">(callback)</span> {</span>
          async.eachSeries(names(data),
            <span class="function"><span class="keyword">function</span> <span class="params">(tableName, callback)</span> {</span>
              <span class="keyword">if</span> (data[tableName]) {
                self.saveMany(transaction.query, tableName, data[tableName], callback);
              }
            },
            callback);
        },
        transaction.commit
      ],
      <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
        <span class="keyword">if</span> (err) {
          <span class="keyword">return</span> transaction.rollback(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> callback(err); });
        }
        callback(<span class="literal">null</span>);
      });
  });
};
</code>
</section>
</div>

</body>
</html>
