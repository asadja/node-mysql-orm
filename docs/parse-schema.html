<!DOCTYPE html>
<!-- Generated by litjs - https://github.com/apres/lit.js
     Part of the Apres suite - http://apres.github.com/ -->
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <title>mysql-orm: parse-schema.js</title>
  <link href='css/lit-callouts.css' rel='stylesheet' type='text/css'>
  <link href='css/apres.css' rel='stylesheet' type='text/css'>
</head>
<body>
  <div class="lit">
<section>
<div class="lit-comment">
<h1>mysql-orm: parse-schema.js</h1>
</div>
<code class="lit-code">
<span class="string">'use strict'</span>;

<span class="comment">/*
 * MySQL object-relational mapping
 * ===============================
 *
 * (C) 2014 Mark K Cowan &lt;mark@battlesnake.co.uk>
 *
 * https://github.com/battlesnake/node-mysql-orm
 *
 * Released under GNU General Public License, Version 2
 *
 */</span>

<span class="keyword">var</span> mysql = require(<span class="string">'mysql'</span>);
<span class="keyword">var</span> async = require(<span class="string">'async'</span>);
<span class="keyword">var</span> _ = require(<span class="string">'underscore'</span>);

<span class="keyword">var</span> utils = require(<span class="string">'./utils'</span>);
<span class="keyword">var</span> names = utils.names;
<span class="keyword">var</span> indent = utils.indent;
</code>
</section>
<section>
<div class="lit-comment">
<h1>parse-schema</h1>

<p>This module is used internally, you should never need to call it yourself.</p>

<h2>parse_schema</h2>

<p>Parses the schema and validates some aspects of it:<br />+ Resolves type aliases in <code>schema.$types</code> and in <code>field.type</code>.<br />+ Resolves references in <code>field.type</code> and <code>field.references</code>.<br />+ Resolves types for implicit references<br />+ Generates names for keys (index/unique) if none was explicity specified.<br />+ Generates names for foreign keys, stores in <code>field.$fkname</code>.<br />+ Stores looked-up type in <code>field.$type</code>; <code>field.type</code> may be overwritten<br />for implicit references by the type of the referred field.</p>
</div>
<code class="lit-code">
module.exports.parse_schema = parse_schema;
<span class="function"><span class="keyword">function</span> <span class="title">parse_schema</span><span class="params">(orm)</span> {</span>
  <span class="keyword">var</span> schema = orm.schema;
  <span class="comment">/* Resolve aliases */</span>
  names(schema.$types).forEach(<span class="function"><span class="keyword">function</span> <span class="title">resolve_alias</span><span class="params">(alias)</span> {</span>
    <span class="keyword">var</span> type = schema.$types[alias];
    <span class="keyword">while</span> (_(schema.$types).has(type) &amp;&amp; schema.$types[type] !== type) {
      type = schema.$types[type];
      <span class="keyword">if</span> (type === alias) {
        <span class="keyword">return</span> orm.error(<span class="string">'Circular type alias dependency for "'</span> +
          alias + <span class="string">'"'</span>);
      }
    }
    schema.$types[alias] = type;
  });
  <span class="keyword">var</span> implicit_refs = [], all_refs = [];
  <span class="comment">/* Process fields */</span>
  names(schema).forEach(<span class="function"><span class="keyword">function</span> <span class="title">parse_table</span><span class="params">(tableName)</span> {</span>
    <span class="keyword">var</span> table = schema[tableName];
    names(table).forEach(<span class="function"><span class="keyword">function</span> <span class="title">parse_field</span><span class="params">(fieldName)</span> {</span>
      <span class="keyword">var</span> field = table[fieldName];
      <span class="comment">/* Resolve aliases */</span>
      <span class="keyword">if</span> (_(orm.schema.$types).has(field.type)) {
        field.type = orm.schema.$types[field.type];
      }
      <span class="comment">/* Store resolved type */</span>
      field.$type = field.type;
      <span class="comment">/* Builtin primary key type */</span>
      <span class="keyword">if</span> (field.type === <span class="string">'::id'</span>) {
        field.type = <span class="string">'INTEGER'</span>;
        field.auto_increment = <span class="literal">true</span>;
        <span class="keyword">if</span> (table.$primary.length > <span class="number">0</span> &amp;&amp;
          !((table.$primary).length === <span class="number">1</span>
            &amp;&amp; table.$primary[<span class="number">0</span>] === fieldName)) {
          <span class="keyword">return</span> orm.error(<span class="string">'Cannot parse field "'</span> + field.$fullname +
            <span class="string">'": table "'</span> + table.$fullname + <span class="string">'" already has '</span> +
            <span class="string">'primary key(s) specified'</span>);
        }
        table.$primary = [fieldName];
      }
      <span class="comment">/* JSON field */</span>
      <span class="keyword">if</span> (field.type.toUpperCase() === <span class="string">'JSON'</span>) {
        field.type = <span class="string">'LONGTEXT'</span>;
        field.serialize = JSON.stringify;
        field.deserialize = JSON.parse;
      }
      <span class="comment">/* Auto-increment */</span>
      <span class="keyword">if</span> (field.auto_increment) {
        table.$auto_increment = fieldName;
      }
      <span class="comment">/* Implicit references */</span>
      <span class="keyword">if</span> (field.type.charAt(<span class="number">0</span>) === <span class="string">':'</span>) {
        <span class="keyword">if</span> (_(field).references) {
          <span class="keyword">return</span> orm.error(<span class="string">'Cannot parse type "'</span> + field.type +
            <span class="string">'" of field "'</span> + field.$fullname + <span class="string">'": a reference '</span> +
            <span class="string">'already exists in this field\'s definition'</span>);
        }
        field.references = field.type.substr(<span class="number">1</span>);
        <span class="keyword">delete</span> field.type;
        implicit_refs.push(field);
      }
      <span class="comment">/* Explicit references */</span>
      <span class="keyword">if</span> (field.references) {
        all_refs.push(field);
      }
      <span class="comment">/* Index */</span>
      <span class="keyword">if</span> (field.index &amp;&amp; !_(field.index).isString()) {
        field.index = field.$name + <span class="string">'_idx'</span>;
      }
      <span class="comment">/* Unique key */</span>
      <span class="keyword">if</span> (field.unique &amp;&amp; !_(field.unique).isString()) {
        field.unique = field.$name + <span class="string">'_uniq'</span>;
      }
      <span class="comment">/* Reference options */</span>
      <span class="keyword">if</span> (field.references) {
        field.onUpdate = reference_option(orm,
          _(field.onUpdate).isString() ? field.onUpdate : <span class="string">'restrict'</span>);
        field.onDelete = reference_option(orm,
          _(field.onDelete).isString() ? field.onDelete : <span class="string">'restrict'</span>);
      }
    });
  });
  <span class="comment">/* Resolve references */</span>
  all_refs.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(field)</span> {</span>
    <span class="keyword">if</span> (_(field.references).isString()) {
      field.references = resolve_field(orm, field.$fullname,
        field.references);
    }
  });
  <span class="comment">/* Generate FK constraint names */</span>
  all_refs.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(field)</span> {</span>
    field.$fkname = [
        field.$name, <span class="string">'fk'</span>, field.references.$table.$name,
        field.references.$name
      ].join(<span class="string">'_'</span>);
  });
  <span class="comment">/* Resolve data types for implicit references */</span>
  <span class="keyword">var</span> unresolved_implicit_refs = implicit_refs.length;
  <span class="keyword">while</span> (unresolved_implicit_refs > <span class="number">0</span>) {
    <span class="keyword">if</span> (!_(implicit_refs).some(
      <span class="function"><span class="keyword">function</span> <span class="title">resolveSome</span><span class="params">(field)</span> {</span>
        <span class="keyword">if</span> (!_(field).has(<span class="string">'type'</span>) &amp;&amp; _(field.references).has(<span class="string">'type'</span>)) {
          field.type = field.references.type;
          unresolved_implicit_refs--;
          <span class="keyword">return</span> <span class="literal">true</span>;
        }
        <span class="keyword">return</span> <span class="literal">false</span>;
      })) {
      <span class="keyword">return</span> orm.error(<span class="string">'Failed to resolve references: Do you have a '</span> +
        <span class="string">'circular dependency between implicitly typed reference '</span> +
        <span class="string">'fields?  fields: '</span> +
        _(implicit_refs).pluck(<span class="string">'$fullname'</span>).join(<span class="string">', '</span>));
    }
  }
}
</code>
</section>
<section>
<div class="lit-comment">
<h2>resolve_field</h2>

<p>Gets a field definition from a string naming the field (e.g. table.field)</p>
</div>
<code class="lit-code">
<span class="function"><span class="keyword">function</span> <span class="title">resolve_field</span><span class="params">(orm, fullname, str)</span> {</span>
  <span class="keyword">var</span> err = <span class="function"><span class="keyword">function</span> <span class="params">(msg)</span> {</span>
    <span class="keyword">return</span> <span class="string">'Failed to resolve field "'</span> + str + <span class="string">'" for field "'</span> + fullname +
      <span class="string">'": '</span> + msg;
  };
  <span class="keyword">var</span> path = str.split(<span class="string">'.'</span>);
  <span class="keyword">if</span> (path.length > <span class="number">2</span>) {
    <span class="keyword">return</span> orm.error(err(<span class="string">'Format: &lt;table name>.&lt;field name>'</span>));
  }
  <span class="keyword">var</span> table = path.shift();
  <span class="keyword">if</span> (table.charAt(<span class="number">0</span>) === <span class="string">'
</body>
</html>
</span> || !_(orm.schema).has(table)) {
    <span class="keyword">return</span> orm.error(err(<span class="string">'Table '</span> + mysql.escapeId(table) + <span class="string">' not found'</span>));
  }
  <span class="keyword">var</span> field = path.shift();
  <span class="keyword">if</span> (_(field).isUndefined()) {
    <span class="keyword">if</span> (orm.schema[table].$primary.length > <span class="number">1</span>) {
      <span class="keyword">return</span> orm.error(err(<span class="string">'Target table "'</span> + table + <span class="string">'" has a '</span> +
        <span class="string">'composite primary key and no target field was explicitly '</span> +
        <span class="string">'specified in the relation definition'</span>));
    } <span class="keyword">else</span>
    <span class="keyword">if</span> (orm.schema[table].$primary.length === <span class="number">0</span>) {
      <span class="keyword">return</span> orm.error(err(<span class="string">'No field was specified and the target '</span> +
        <span class="string">'table "'</span> + table + <span class="string">'" has no primary key defined to use as '</span> +
        <span class="string">'default'</span>));
    }
    field = orm.schema[table].$primary[<span class="number">0</span>];
  }
  <span class="keyword">if</span> (field.charAt(<span class="number">0</span>) === <span class="string">'
</body>
</html>
</span> || !_(orm.schema[table]).has(field)) {
    <span class="keyword">return</span> orm.error(err(<span class="string">'Field '</span> + mysql.escapeId(field) + <span class="string">' was not '</span> +
      <span class="string">'found in table '</span> +  mysql.escapeId(table)));
  }
  <span class="keyword">return</span> orm.schema[table][field];
}
</code>
</section>
<section>
<div class="lit-comment">
<h2>reference_option</h2>

<p>Helper function to parse reference_option values</p>
</div>
<code class="lit-code">
<span class="function"><span class="keyword">function</span> <span class="title">reference_option</span><span class="params">(orm, value)</span> {</span>
  value = value.toUpperCase();
  <span class="keyword">if</span> (!_([<span class="string">'RESTRICT'</span>, <span class="string">'CASCADE'</span>, <span class="string">'SET NULL'</span>, <span class="string">'NO ACTION'</span>]).contains(value)) {
    orm.warn(<span class="string">'unrecognised reference_option: '</span> + value);
  }
  <span class="keyword">return</span> value;
}
</code>
</section>
</div>

</body>
</html>
